数据库的索引

二叉搜索树加上叶子节点的链表，

使用范围查找的时候

```sql
select*from table where id>12;
```

找到12，然后用链表遍历就好了。



但是，最大值是2·32次，那么树就有32层

- 搜索需要32次
- 需要从磁盘读取32次数据，32次IO
- 如何减少？



B More树，一个节点会有2+个子节点

M阶的B+树

- 每个节点最多有m个子节点
- 除根节点外，每个节点至少有m/2个子节点，注意如果结果除不尽，就向上取整，比如5/2=3，3/2=2
- 根节点要么是空的要么独根，否则至少有2个子节点
- 有k个子节点的必有k个关键码
- 叶节点的高度一致 （满树，连续）

插入：节点分裂：当叶子节点不够了需要分裂 **m/2**

删除：节点合并

SQL中Btree的应用

- 阶数：16kb（页的大小）/（8b+8b） 1024个节点 1024阶的B+Tree
- mysql的层数一般不多，层数和数据有关，阶数和索引的大小有关

字符串：字典序，ascii

联合索引，最左匹配原则（id,name） `like a%`可以走索引

如何建立索引

```
索引不能建太多，因为B+树的插入和删除是需要维护的，太多的索引会导致插入变慢
建了索引的字段不能使用like ‘%%’ 否则是失效的
建索引的字段类型不能太大，字段越小阶数就越小，效率就越高
建索引的字段值不能太多一样的，比如我们把性别建索引会出现啥情况？左边都是一样的值，过滤不了一半
联合索引的最左匹配原则
NOT IN是不会走索引的
```

### **总结**

**二叉查找树**：二叉搜索树，优点查找快，但是在某些情况下会退化成链表

**红黑树**：内存查找高效树，不适合大数据量，也不适合磁盘存储，具体的分析就是IO浪费以及读取资源浪费，还有就是树的深度会很大。适合做一些底层系统做内存运算

BTree可以认为是B+的过度

**B+Tree**：最适合大数据的磁盘索引，经典的MySql，所有的数据都存在叶子节点，其他都是索引，增加了系统的稳定性以及遍历以及查找效率

M阶，这个由磁盘的页面大小决定，磁盘块和页内存都是4KB，我们的节点数也就是我们的M值，尽可能和他一样，1 0.75原则HashMap，这样的好处就是为了我们一次刚好能全部拿出一个节点里面存的所有数据