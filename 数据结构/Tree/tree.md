**二叉搜索树**

- 如果左子树不为空，左子树的节点都小于根节点
- 如果右子树不为空，右子树上节点都大于根节点
- 子树遵循以上规则

中序遍历（左中右）一定是有序的



二叉查找算法：

猜数字，0-100出个数让你猜，每次会告诉你大了还是小了

50 大了-》51-100

每次可以排除一半的空间， **logn**，有序的序列



如何删除：

分三种情况：

```
叶子节点，直接删除 O（1）
要删除的节点只有一个子树（左或者右）O（1）
要删除的节点有两颗子树，找后继节点，而且后继节点的左子树一定为空，右子树无所谓 
因为要找后继节点：logn
```

性能分析：

查找 logn

插入 nlogn：插入一次就相当于查找一次，插入N个就是n*logn



但是二叉查找树会有可能变成链表，复杂度成为O(n)

AVL树的维护平衡开销较大



**红黑树**

- 每个节点不是红色就是黑色
- 不可能有连在一起的红色节点，每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据
- 根节点都是黑色root
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点





**红黑树的插入：**

```
所有新加的点必须是红色
当前点是红色
父节点是红色-》黑叔
叔叔也是红色-》黑色
爷爷节点-》红色
（这个时候指向爷爷节点）
左旋条件：
1，父节点是红色
2，叔叔节点是黑色
3，当前节点是右子树，以父节点左旋
（这时指向当前节点的父节点）
右旋条件：
当前父节点是红色，叔叔节点是黑色，且当前的节点是左子树，右旋：
1把父节点变成黑色
2把祖父节点变成红色
3以祖父节点旋转
```



**AVL树的操作**

左旋：

在生成树的时候，根据性质，来进行左旋右旋的操作：

```
   9                          这种情况为左-左型，对节点9进行右旋操作，就变成了
 5
4
```

```
  5
4   9
```

**顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子**

```
这种情况 4的高度为2，9的为0， 右旋
         6
     4       9
  3    5
2
```

```
     4
   3    5
 2         6
              9
这时5-6-9为右-右，做一个左旋
```

```
       4
    3      6
  2      5   9
```

对于**右-左型**和**左-右型**：

```\
7                   9
  10              7
9                   8
```

先右旋：                          先左旋：

```
7                   9 
  9               8
    10           7
```

再左旋

```
  9                  8
7   10             7    9
```

---

