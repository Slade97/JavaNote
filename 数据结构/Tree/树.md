链接:https://zhuanlan.zhihu.com/p/91071103

### 树的遍历

```
先序：根左右
中序：左根右
后序：左右根
```



### 二叉查找树BST：

```
1、若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值。

2、若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值。

3、它的左右子树也分别可以充当为二叉查找树。
```



利于查找，每次判断大小即可

因为结构类似于：

```
             Mid:medium:
LEFT :small              RIGHT:large
```

**缺陷**：

如果：

```

        5
      4   6 
     3       7
   2
 1
0
```

这样查找趋向于线性查找了。效率很低。

### AVL树

```
1、二叉查找树的性质

2、每个节点的左子树和右子树的高度差最多为1
```

在生成树的时候，根据性质，来进行左旋右旋的操作：

```
   9                          这种情况为左-左型，对节点9进行右旋操作，就变成了
 5
4
```

```
  5
4   9
```

**顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子**

```
这种情况 4的高度为2，9的为0， 右旋
         6
     4       9
  3    5
2
```

```
     4
   3    5
 2         6
              9
这时5-6-9为右-右，做一个左旋
```

```
       4
    3      6
  2      5   9
```

对于**右-左型**和**左-右型**：

```\
7                   9
  10              7
9                   8
```

先右旋：                          先左旋：

```
7                   9 
  9               8
    10           7
```

再左旋

```
  9                  8
7   10             7    9
```



### 红黑树 ###

https://zhuanlan.zhihu.com/p/143396578

二叉查找树性质：

```
1.左子树上所有结点的值均小于或等于它的根结点的值。

2.右子树上所有结点的值均大于或等于它的根结点的值。

3.左、右子树也分别为二叉排序树。
```

红黑树性质：

```
1.结点是红色或黑色。

2.根结点是黑色。

3.每个叶子结点都是黑色的空结点（NIL结点）。

4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)

5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
```

红黑树插入的规则：

**局面1：**

新节点位于树根，没有父节点。

直接让新节点变为黑色，满足规则2，

**局面2：**

新节点B的父节点是黑色

新插入的红色节点B并没有打破红黑树的规则，不需要调整

**局面3：**

新节点D的父节点B和叔叔节点C都是红色。

这种局面，两个红色节点B,D连续，违反了规则4，因此我们先让节点B变为黑色。

这样的话，节点B所在的路径凭空多了一个黑色节点，打破了规则5，我们让根节点A变成红色。满足了规则5，然后再让叔叔节点变成黑色。这一局面重新符合了红黑树的规则/

**局面4：**

新节点D的父节点是红色，叔叔节点是黑色或者没有叔叔，且新节点是父节点的右孩子，父节点B是祖父节点的左孩子

![](.\img\红黑树p4.jpg)

做一次左旋：

使得新节点D成为父节点，原来的父节点B成为D的左孩子：

![](.\img\红黑树p4-1.jpg)

这样，进入了局面5

**局面5：**

新节点D的父节点是红色，叔叔节点是黑色或者没有叔叔，且新节点是父节点的左孩子，父节点是祖父节点的左孩子。

![](.\img\红黑树p5-1.jpg)

我们以节点A为轴，做一次右旋转，使得节点B作为祖父节点，节点A成为节点B的右孩子

![](.\img\红黑树p5-2.jpg)

然后，我们让节点B变成黑色，节点A变成红色：

![](.\img\红黑树p5-3.jpg)

红黑树删除。。。