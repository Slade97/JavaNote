```
最短路径用什么数据结构和算法呢？
```

DFS：

图：

线性表：数组+链表

非线性表：树+图

**使用图**：大图用邻接表，小图用邻接矩阵

边看成路，点看成路口



**算法**

贪心算法：局部最优推出全局最优，

DFS：肯定可以解决问题，开销和路径数量直接相关



使用**迪杰斯特拉算法**，即单元最短路径算法，它是所有最短路径算法的基础，我们的地图软件最终使用的算法也是以他为基础进行的优化。

算法核心思路分析：

问题：求1到其他任意点的最短路径

核心思想分析：贪心：排序，贪心策略。1-3我们认为是10

1.我们开一个dis数组，用来表示起始点到每个顶点的距离，最开始的值我们赋值为无穷大

2.加变量loc，初始赋值为起始点。贪心策略：在dis数组中找离初始值最近的那个点

3.通过loc更新dis数组，因为加入一个点后我们就可以更新路径

4.在dis数组里面找离初始点最近的那个点，排除已经选择过的点，将之赋值给loc

5.重复执行3 4 操作，直到所有点加完

以上这个思路就叫松弛操作

```
首先，建立一个dis数组，标记节点1能到其他节点的最短路径，如果不能直接到达，则设置为无穷大值[0,INT,10,INT,30,100]
然后，在这个dis数组中，选择离初始值最近的那个点，比如3,3-》4的距离是50，那么1就可以通过3到4，为10+50=60.我们把这个值和dis数组里面的值进行比较：
min(dis[3]+data[3][4],dis[4])，选择小的更新dis数组，这很想背包问题。
此视dis为[0,INT,10,60,30,100]
loc变量加了1，3， 现在我们选择5节点，因为5节点的值目前最小。
5可以到4和6， data[5][4]=20 data[5][6]=60;根据上一步的操作：
min(dis[5]+data[5][4],dis[4])=min(60,50),更新dis[4]为50.
min(dis[5]+data[5][6],dis[6])=min(90,100),更新dis[6]为50.
此时dis为[0,INT,10,50,30,90]
loc变量为1.3.5
现在我们选择4节点
。。。。。。
```

