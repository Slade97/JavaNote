## Hash 算法

Hash冲突

Hash算法的时间复杂度取决于散列函数，最理想的是O[1],最差的是O[n]

**开放寻址：**

```
如果出现了散列冲突，那么我们就依次向后寻找空位储存
```

**链路地址：**

```
其实就是使用链表，链表法是一种更加常用的散列冲突解决办法
```



JDK自带的hash函数：

```
int hash(Object key){
 int h=key.hashCode();
 return (h`h(>>>16))&(capitity-1)//capicity表示散列表的大小，一般为数据长度的2倍
}
```

常用的哈希函数就是

```
%n
```

具体的应用：

1. 加密，md5，哈希算法，还是存在密码冲突，128位的二进制串，可以表示2·128次，md5算法是不可逆的。
2. 相似性检测，论文检测，指纹算法，会把每个论文计算出一个指纹，汉明距离
3. 负载均衡，nginx，比如2台服务器，根据ip计算hash，再做一个取模2的运算%2
4. 分布系统，数据分库问题，大数据分成10个文件，hash（key）%10=》就可以知道某个key在哪一个文件，扩大成数据库的分表
5. 分布式存数的时候，问题来了，如果我加了一张表，变成11张了，要重新计算

一致性Hash：哈希环

```
假设我们有K个表，数据的hash值范围，[0,Integer.max]，我们把整个数据范围划分成n个区间（n个区间远大于我们的k），每个表就是分配到n/k的区间，当有新表要来的时候，我们只需要将某几个小的区间数据迁移就可以了。
```



设计hash表的原则：

- 必须要高效，即插入删除，查找必须要快
- 内存：不能占用太多的内存，红黑树内部的操作很浪费空间（左右旋）考虑其他的数据结构，比如b+树，hashmap，mysql存硬盘就用了b+树
- hash函数，根据实际情况考虑，取模%
- 扩容：就是预估数据的大小，Hashmap的默认空间是16，如果我知道我的数据是1w+，那么我直接开一个1w+的hashmap
- hash冲突的解决，数组，链表