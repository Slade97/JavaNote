**Hash扩容算法在多线程情况有什么问题？**

元素丢失，闭环死循环（CPU 100%）

**如何在3亿个整数（0-2亿）中判断一个数是否存在？内存限制500M**

```
分治
布隆过滤器
Redis
Hash：开三亿个空间。。
数组：data[2亿]，0代表没有，1代表有
Bit： bitmap 位图
```

最小的单位： bit byte

1 Byte=8 bit

int = 4 byte =4*8 bit

float=4 byte

long=8 byte

char =2 byte

```
int a=1 在计算机中怎么存的？
0000 0000 0000 0000 0000 0000 0000 0001
左移
8<<2=8*4=32
8:
0000 0000 0000 0000 0000 0000 0000 1000: 2`3=8
0000 0000 0000 0000 0000 0000 0010 0000:2`5=32
右移
8>>2=8/4=2
0000 0000 0000 0000 0000 0000 0000 1000: 2`3=8
0000 0000 0000 0000 0000 0000 0000 0010: 2`1=2

位与&：同位上两个数都是1则位1，否则为0
位或|：同位上两个数只要有一个为1，则位1，否则为0
```

回到问题：

```
如何在3亿个整数（0-2亿）中判断一个数是否存在？内存限制500M
用int来存，一个int为32bit， 我们用一个int来存32个数字，每一位代表一个数字是否存在 0代表不存在，1代表存在。
这样空间就会节省了32倍！ 我们开int[MAX/32+1]数组就可以存储完这些数据。
因为用bit保存的数字是连续的，所以我们开的数组大小和这组数字的最大值有关

```

```
数组[2,3,65]
最大数是65，data[65/32+1]=data[3]:
data[0]:0000 0000 0000 0000 0000 0000 0000 1100 0-31
data[1]:0000 0000 0000 0000 0000 0000 0000 0000 32-63
data[2]:0000 0000 0000 0000 0000 0000 0000 0010 64-95
data[3]:0000 0000 0000 0000 0000 0000 0000 0000
规律：
2/32=0，说明放在data[0]的位置上，2%32=2说明在data[0]的位置2上
65/32=2，说明放在data[2]的位置上，65%32=1,说明在data[2]的位置1上
```

计算空间，2亿， 最大的数就是2亿

那么需要去空间就是：2亿*4/1024/1024=762M（一个int是4个字节，kb-》mb）

使用bitmap=762/32=23M

```
判断一个数是否存在，思路同上，
比如66：
66/32=2   66%32=2，所以就在data[2]的第二位上去找，看这位数字是否为1即可。
```

