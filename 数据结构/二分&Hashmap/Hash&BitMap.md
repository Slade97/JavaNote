**Hash扩容算法在多线程情况有什么问题？**

元素丢失，闭环死循环（CPU 100%）

**如何在3亿个整数（0-2亿）中判断一个数是否存在？内存限制500M**

```
分治
布隆过滤器
Redis
Hash：开三亿个空间。。
数组：data[2亿]，0代表没有，1代表有
Bit： bitmap 位图
```

最小的单位： bit byte

1 Byte=8 bit

int = 4 byte =4*8 bit

float=4 byte

long=8 byte

char =2 byte

```
int a=1 在计算机中怎么存的？
0000 0000 0000 0000 0000 0000 0000 0001
左移
8<<2=8*4=32
8:
0000 0000 0000 0000 0000 0000 0000 1000: 2`3=8
0000 0000 0000 0000 0000 0000 0010 0000:2`5=32
右移
8>>2=8/4=2
0000 0000 0000 0000 0000 0000 0000 1000: 2`3=8
0000 0000 0000 0000 0000 0000 0000 0010: 2`1=2

位与&：同位上两个数都是1则位1，否则为0
位或|：同位上两个数只要有一个为1，则位1，否则为0
```

回到问题：

```
如何在3亿个整数（0-2亿）中判断一个数是否存在？内存限制500M
用int来存，一个int为32bit， 我们用一个int来存32个数字，每一位代表一个数字是否存在 0代表不存在，1代表存在。
这样空间就会节省了32倍！ 我们开int[MAX/32+1]数组就可以存储完这些数据。
因为用bit保存的数字是连续的，所以我们开的数组大小和这组数字的最大值有关

```

```
数组[2,3,65]
最大数是65，data[65/32+1]=data[3]:
data[0]:0000 0000 0000 0000 0000 0000 0000 1100 0-31
data[1]:0000 0000 0000 0000 0000 0000 0000 0000 32-63
data[2]:0000 0000 0000 0000 0000 0000 0000 0010 64-95
data[3]:0000 0000 0000 0000 0000 0000 0000 0000
规律：
2/32=0，说明放在data[0]的位置上，2%32=2说明在data[0]的位置2上
65/32=2，说明放在data[2]的位置上，65%32=1,说明在data[2]的位置1上
```

计算空间，2亿， 最大的数就是2亿

那么需要去空间就是：2亿*4/1024/1024=762M（一个int是4个字节，kb-》mb）

使用bitmap=762/32=23M

```
判断一个数是否存在，思路同上，
比如66：
66/32=2   66%32=2，所以就在data[2]的第二位上去找，看这位数字是否为1即可。
```

时间复杂度是O[1]。

```java
public class BitMap {
    byte[]bits;
    int max;

    public BitMap(int max){
        this.max=max;
        bits=new byte[(max>>3)+1];
    }
    public void add(int n){
        int bitsIndex=n>>3;//在哪个byte
        int loc=n%8;//这个可以用&运算

        //下面我们把bit数组里面的bitsIndex这个下标的byte里面的第loc个bit位置为1
        bits[bitsIndex] |=1<<loc;
    }
    public boolean find(int n){
        int bitsIndex=n>>3;//在哪个byte
        int loc=n%8;//这个可以用&运算

        int flag=bits[bitsIndex]&(1<<loc);
        if(flag==0) return false;
        return true;
    }

    public static void main(String[] args) {
        BitMap bitmap=new BitMap(100);
        bitmap.add(2);
        bitmap.add(3);
        bitmap.add(65);
        bitmap.add(66);

        System.out.println(bitmap.find(3));
        System.out.println(bitmap.find(64));
    }
}

```

能解决的问题：

- 数据判重
- 对没有重复的数据排序，既然处理不了重复的数据（因为位运算是0和1），那么也处理补了哈希冲突。**范围问题**，假设0到10亿的10个数，我们用bitmap的话需要开10亿/32个空间，如果用hashmap只需要用10个就好了
- 根据前两条可以扩展出很多其他的应用，比如找不重复的数，统计数据等