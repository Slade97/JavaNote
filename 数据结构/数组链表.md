### 数组

tips：

```java
数组的下标可以充分利用，用来统计数字
while(...){
...
int[num]++
}
```

- **相同数据类型**元素的集合

- 有序的，在内存中**按照先后顺序存储**，内存地址连续的

- 开多维数组的话，内存是乘积的形式：n*m，所以一般用链表解决

- 随机访问，

- 查找方便，插入低效

  ```
  因为数组是有序的，插入按序查找就好了o[1]的复杂度
  插入/删除很低效，因为内存地址连续，插入/删除一个元素，后面的元素都需要迁移，复杂度0[n]
  ```

  

**实现一下数组**

```java
public class ArrayTest {
    /**
     * 自己实现一下数组
     *其实就是ArrayList的部分源代码
     * */
    private int size;
    private int data[];
    private int index;

    public ArrayTest(int size) {
        this.size = size;
        data=new int[size];
        index=0;
    }
    public void print(){
        System.out.println("index:"+index);
        for (int i = 0; i <index ; i++) {
            System.out.print(data[i]+" ");
        }
        System.out.println();
    }
    public void insert(int loc,int n){
        if(index++<size){
            for (int i = size-1; i >loc ; i--) {
                data[i]=data[i-1];
            }
            data[loc]=n;
        }else {//扩容
            size=size*2;
            int[]data1=new int[size];
            for (int i = 0; i <data.length ; i++) {
                data1[i]=data[i];
            }
            data=data1;
            insert(loc, n);
        }
    }

    public void delete(int loc){
        for (int i = loc; i <size ; i++) {
            if(i!=size-1){
                data[i]=data[i+1];
            }else {
                data[i]=-1;
            }
        }
        index--;
    }
    public void update(int loc,int n){
        data[loc]=n;
    }
    public int get(int loc){
        return data[loc];
    }
}
```

### ArrayList和数组

本质是一样的，都是数组，ArrayList是JDK封装了，不需要处理扩容操作

- 不知道数据大小的肯定AL
- 知道Size，关注性能的话，用数组

数组最需要的是注意越界，多加判断。



**二维数组的地址是连续的**

比如

```java
123
456
4的下标在二维数组里面是（1，0） 在一维里面是第三个，
寻址公式： loc=init_loc（初始内存地址）+（i*n（一维的长度）+j（在列））*size
```





**String的面试题**

```java
String s1="ja";
String s2="va";
String s3="java";
String s4=s1+s2;//java注意这个+号，java里面重载了加号，其实调用了stringBuild，会new一个对象
System.out.println(s3==s4);//false
System.out.println(s3.equals(s4));//true,equals()只是比较值
```

### 链表

面试题：

```
如何设计一个LRU缓存淘汰算法？

约瑟夫问题
```

**定义**

链表通过指针将一组零散的内存块串联在一起（无序），其中，我们把内存块称为链表的节点，为了将所有的节点串起来。

和数组对比：

- 同样数据大小的话，链表更大，因为需要存指针
- 不需要连续的空间
- 不能随机查找了

常见的链表结构：单链表，循环链表（尾节点.next=头节点），双向链表（node.prev,node.next）

链表的查询和插入/删除

```java
//查询：从头遍历节点，直到末尾，复杂度O[n]
//插入删除：头，尾，中间

//插入一个s节点
s.next=p.next;
p.next=s;
//删除
p.next=p.next.next;
```

判断链表结束`node.next==null`

**双向链表**

存了两个指针 prev+next

支持双向遍历了，但是存了更多指针，更浪费空间